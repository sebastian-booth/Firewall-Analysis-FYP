from faker import Faker # joke2k (2021) Faker is a Python package that generates fake data for you.(8.14) [Package]. https://pypi.org/project/Faker/ [Accessed 14/05/2021]
from collections import defaultdict
import ipaddress
import random
import re
import subprocess
import string
import networkx as nx # Aric Hagberg (2021) Python package for creating and manipulating graphs and networks (2.1.5) [Package]. https://pypi.org/project/networkx/ [Accessed 14/05/2021]
import matplotlib.pyplot as plt # John D. Hunter, Michael Droettboom (2021) Python plotting package (3.4.2) [Package]. https://pypi.org/project/matplotlib/ [Accessed 14/05/2021]
import ast
import csv

def bus_topology(network_model):
    alphabet =  list(string.ascii_uppercase)
    subnets = dict()
    diagram_model = None
    count = 0
    if network_model.casefold() == "b".casefold():
        diagram_model = "bus/network_bus.diag"
    for x in range(random.randint(3,5)): # generate a random number of subnets each with a network address from Faker Library
        subnets[x] = Faker().ipv4(private=True, network=True, address_class="c")
        subnets["site"+alphabet[x]] = subnets.pop(x)
    print("Network subnets", subnets)
    hosts = defaultdict(list)
    for x in list(subnets.values()): # using the work addresses generated by Faker input them into the ipaddress library to return all possible host IP addresses
        count += 1
        for ip in ipaddress.IPv4Network(x):
            hosts['site%s' % alphabet[count-1]].append('%s' % ip)
    usage_hosts = defaultdict(list)
    for key, value in hosts.items(): # Iterate the possible host IPs and pick a random number of them to be used in the model
        for x in range(random.randint(4, 7)):
            usage_hosts[key].append('%s' % random.choice(value))
    hosts_used = {a:list(set(b)) for a, b in usage_hosts.items()} # Ajax1234 (2017) Remove duplicate values from dict [Snippet]. https://stackoverflow.com/a/44395628 [Accessed 14/05/2021]
    port_conf = get_ports(hosts_used) # call the get_ports function with the determined hosts
    print(hosts_used)
    print(" ")
    service_count = 0
    file = open(diagram_model, "w+")
    file.write("nwdiag {\n") # Begin writing to nwdiag file to render network model diagram
    counter = 0
    hosts_used_value = list(hosts_used.values())
    subnet_value = list(subnets.values())
    for y in hosts_used: # For each of the subnets used in the network, write their applicable network addresses into a separated sections
        counter_2 = 1
        counter_3 = 0
        if y == port_conf[0]: # Hosts in the server farm (site A) denote its network location
            file.write("network " + y + " {\n")
            file.write("    address = " + '"' + subnet_value[counter] + '"' + "; // Server farm located here\n")
        else:
            file.write("network " + y + " {\n") # Write the address of each subnet
            file.write("    address = " + '"' + subnet_value[counter] + '"' + ";\n")
        for x in hosts_used_value[counter]: # For each host used in these subnets write their applicable hostname and IP addresses based on counter values
            if str(alphabet[counter]) == port_conf[0][-1]: # If at writing the server farm include the service gathered from get_ports
                file.write("    " + str(alphabet[counter]) + str(counter_2) + " " + '[address = "' + str(hosts_used_value[counter][counter_3]) + '"]; // Service: ' + port_conf[1][service_count] + '\n')
                service_count+=1
            else:
                file.write("    " + str(alphabet[counter]) + str(counter_2) + " " + '[address = "' + str(hosts_used_value[counter][counter_3]) + '"];\n')
            if counter_3 < len(hosts_used_value[counter]):
                counter_3+=1
            if counter_3 == len(hosts_used_value[counter]):
                break
            counter_2 += 1
        file.write("}\n")
        counter+=1
    file.write("}")
    file.close()
    counter_5 = 0
    iterate_subnets = 0
    counter_7 = 0
    if network_model.casefold() == "b".casefold():
        with open(diagram_model, "r") as file: # gw injector
            read = file.readlines()
            sep = " "
            sep = sep.join(read)
            count_subnets = sep.split().count('network')
            print(count_subnets)
            gw_append = []
            for line in read:
                gw_append.append(line)
                if "network site%s" % alphabet[counter_5] in line: # Interpret where the current subnets are located in the network model and inject several gateways into the configuration based on the surrounding subnets
                        gw_subnet = read.index("network site%s {\n" % alphabet[counter_5]) + 1
                        subnet_gw = (re.findall(r'"([^"]*)"', read[gw_subnet]))  # Martijin Pieters (2014) Extract a string between double quotes [Snippet]. https://stackoverflow.com/a/22735466 [Accessed 14/05/21]
                        gw_ip = list(ipaddress.ip_network(subnet_gw[0]).hosts())
                        try:
                            gw_ip = str(random.choice(gw_ip))
                        except:
                            bus_topology(network_model)
                            exit()
                        gw_append.append('    gw'+str(counter_7) + ' [address = "' + gw_ip + '"];' '\n')
                        counter_5+=1
                        subnet_selector1 = 1
                        subnet_selector2 = 2
                        if count_subnets > 4:
                            subnet_selector1 =count_subnets - 3
                            subnet_selector2 =count_subnets - 2
                        iterate_subnets+=1
                        if count_subnets % 2 == 1 and iterate_subnets == count_subnets-1: # Determine position of subnet relative to other nearby subnets and insert gateway configuration at correct index
                            gw_subnet = read.index("network site%s {\n" % alphabet[iterate_subnets-1]) + 1
                            print(read[gw_subnet])
                            subnet_gw = (re.findall(r'"([^"]*)"', read[gw_subnet]))  # Martijin Pieters (2014)
                            gw_ip = list(ipaddress.ip_network(subnet_gw[0]).hosts())
                            gw_ip = str(random.choice(gw_ip))
                            gw_append.append('    gw' + str(counter_7+1) + ' [address = "' + gw_ip + '"];' '\n')
                        if count_subnets > 3 and iterate_subnets == count_subnets-1: # edit second condition for subnets greater 4 (6)
                            gw_subnet = read.index("network site%s {\n" % alphabet[iterate_subnets-subnet_selector1]) + 1
                            print(read[gw_subnet])
                            subnet_gw = (re.findall(r'"([^"]*)"', read[gw_subnet]))  # Martijin Pieters (2014)
                            gw_ip = list(ipaddress.ip_network(subnet_gw[0]).hosts())
                            gw_ip = str(random.choice(gw_ip))
                            gw_append.insert(gw_subnet+2,'    gw' + str(counter_7+2) + ' [address = "' + gw_ip + '"];' '\n')

                            gw_subnet = read.index("network site%s {\n" % alphabet[iterate_subnets-subnet_selector2]) + 1
                            print(read[gw_subnet])
                            subnet_gw = (re.findall(r'"([^"]*)"', read[gw_subnet]))  # Martijin Pieters (2014)
                            gw_ip = list(ipaddress.ip_network(subnet_gw[0]).hosts())
                            gw_ip = str(random.choice(gw_ip))
                            gw_append.insert(gw_subnet+2,'    gw' + str(counter_7+2) + ' [address = "' + gw_ip + '"];' '\n')
                        if iterate_subnets % 2 == 0:
                                counter_7 += 1
            if count_subnets == 4:
                gw_append = [sub.replace('gw3', 'gw2') for sub in gw_append] # Fixes a naming issue with the gateway injector
            with open('bus/network_bus.diag', 'w') as file: # Write amended lines to configuration file
                file.writelines(gw_append)
                file.flush()

    with open(diagram_model, 'r') as file: # Read every line in configuration file and check if any duplicate IP addresses are found
        extract_quote = file.read().replace('\n', '')
        extract_quote = re.findall(r'"([^"]*)"', extract_quote)
        if len(set(extract_quote)) != len(extract_quote): # If duplicates are found restart the function
            print("dupes found")
            file.close()
            bus_topology(network_model)

    subprocess.check_output(['nwdiag', '--no-transparency', diagram_model]) # Takeshi Komiya (2020) nwdiag generates network-diagram image from text (2.0.0) [Package]. https://pypi.org/project/nwdiag/ [Accessed 14/05/21]
    print("check network.png for diagram") # Spawns a sub process to run nwdiag with the configuration file generating the diagram
    subnet_routing_store = None
    src_ip_list = None
    dest_ip_list = None
    subnets_listed = None
    routing_table_gen(network_model, subnet_routing_store, src_ip_list, dest_ip_list, subnets_listed, alphabet, subnets) # Calls routing table generation

def star_topology(network_model):
    '''
    This function fundamentally works the same as bus_topology in terms of its data generation with the exception of
    applying the network configurations into networkx which is used to to draw the network diagram with matplotlib.
    On top of this it to provide persistent storage it will also write the network connections to a text file.
    However unlike bus topology this function determines the default gateway of each host due to them using direct
    1 to 1 connections.
    '''
    alphabet =  list(string.ascii_uppercase)
    subnets = dict()
    star_graphs = dict()
    star_host_ips = defaultdict(list)
    count = 0
    src_ip = None
    dest_ip = None
    src_ip_list = []
    dest_ip_list = []
    union_edges = []
    subnet_num = random.randint(3,5)
    star_hosts = defaultdict(list)
    star_hosts_limited = defaultdict(list)
    print(star_hosts)
    for x in range(subnet_num):
        subnets[x] = Faker().ipv4(private=True, network=True, address_class="c")
        subnets["site" + alphabet[x]] = subnets.pop(x)
    print("Network subnets", subnets)
    star_host_num = []
    for y in range(subnet_num):
        counter = 1
        num_hosts = random.randint(5,7)
        star_host_num.append(num_hosts*2)
        for i in range(num_hosts):
            star_hosts['site%s' % alphabet[y]].append('R({0})'.format(alphabet[y]))
            star_hosts['site%s' % alphabet[y]].append('{0}{1}'.format(alphabet[y], counter))
            star_hosts_limited['site%s' % alphabet[y]].append('{0}{1}'.format(alphabet[y], counter))
            counter+=1
    port_conf = get_ports(dict(star_hosts_limited))
    star_hosts_lists_no_split = list(star_hosts.values())
    star_hosts_lists = list(star_hosts.values())
    print(star_hosts_lists)
    print(len(star_hosts_lists))
    for z in range(len(star_hosts_lists)):
        star_hosts_lists[z] = [star_hosts_lists[z][i:i+2] for i in range(0,len(star_hosts_lists[z]),2)] # unutbu (2010) Creating sublists [Snippet]. https://stackoverflow.com/a/4501720 [Accessed 14/05/21]
    print(star_hosts_lists)
    for x in range(len(star_hosts_lists)):
        star_graphs["G_%s" % alphabet[x]] = nx.Graph()
        star_graphs["G_%s" % alphabet[x]].add_edges_from(star_hosts_lists[x])
    star_graphs_values = list(star_graphs.values())
    star_graph_union = nx.union_all(star_graphs_values)
    for y in range(len(star_hosts_lists)-1):
            star_graph_union.add_edge('R(%s)' % alphabet[y] , 'R(%s)' % alphabet[y+1])
            union_edges.append(['R(%s)' % alphabet[y] , 'R(%s)' % alphabet[y+1]])
    plt.figure(figsize=(10,10))
    pos_union = nx.spring_layout(star_graph_union)
    nx.draw(star_graph_union, pos=pos_union, node_color="#A0CBE2", width=1.2, node_size=1400, with_labels=True)
    print(star_host_num)
    for x in list(subnets.values()):
        count += 1
        for ip in ipaddress.IPv4Network(x):
            star_host_ips['site%s' % alphabet[count - 1]].append('%s' % ip)
    star_usage_hosts = defaultdict(list)
    count = 0
    print(star_hosts_lists_no_split)
    for key, value in star_host_ips.items():
        if value not in star_usage_hosts[key]:
            try:
                star_usage_hosts[key].append('%s' % random.sample(value,star_host_num[count]))
            except:
                print("Not enough valid IPs in CIDR, restarting")
                plt.close()
                star_topology(network_model)
                exit()
        count+=1
    plt.savefig('star/network_star.png')
    fixed_star_hosts = defaultdict(list)
    for y in range(len(star_host_num)):
        fixed_star_hosts["site%s" % alphabet[y]].append(ast.literal_eval(star_usage_hosts["site%s" % alphabet[y]][0]))
    print(fixed_star_hosts)
    print(" ")
    star_net_config = open("star/network_star.txt", "w")
    subnets_listed = list(subnets.values())
    subnet_routing_store = []
    for x in range(len(subnets_listed)):
        star_net_config.write(subnets_listed[x] + " - %s\n\n" % alphabet[x])
        subnet_routing_store.append(subnets_listed[x] + " - %s\n\n" % alphabet[x])
    star_net_config.write("Connections:\n")
    count = 0
    service_count = 0
    hosts_used = list(fixed_star_hosts.values())
    routing_table_store = open("star/default_routing_s.csv", "w+")
    fields = ["Hostname", "Source IP", "Default Gateway"]
    writer = csv.DictWriter(routing_table_store, fields)
    writer.writeheader()
    for (counter, y) in enumerate(hosts_used):
        host_count = 1
        host_len = len(y[0])
        print(port_conf)
        if port_conf[0][-1] == str(alphabet[counter]):
            star_net_config.write("// Server farm located here\n")
        for i in range(int((len(y[0])) / 2)):
            if port_conf[0][-1] == str(alphabet[counter]):
                star_net_config.write(str(alphabet[counter]) + str(host_count) + " (Service: " + str(port_conf[1][service_count]) +"): eth0 - "+ str(y[0][count]) + " <-----> " + "R(%s)" % alphabet[counter] + ": eth%s - " % str(count) + str(y[0][host_len -1]) +  "\n")
                service_count += 1
            else:
                star_net_config.write(str(alphabet[counter]) + str(host_count) + ": eth0 - "+ str(y[0][count]) + " <-----> " + "R(%s)" % alphabet[counter] + ": eth%s - " % str(count) + str(y[0][host_len -1]) +  "\n")
            writer.writerow({'Hostname': str(alphabet[counter]) + str(host_count), 'Source IP': str(y[0][count]), 'Default Gateway': str(y[0][host_len -1]) + " (" + "R(%s)" % alphabet[counter] + "- eth%s)" % str(count)})
            host_len-=1
            count+=1
            host_count+=1
        if counter != len(hosts_used) - 1:
            star_net_config.write("\n")
            if counter == 0:
                src_ip = str(random.choice(list(ipaddress.ip_network(subnets_listed[counter]).hosts())))
                dest_ip = str(random.choice(list(ipaddress.ip_network(subnets_listed[counter + 1]).hosts())))
                star_net_config.write("R(%s)" % alphabet[counter] + ": eth%s - " % str(count) + src_ip +  " <-----> " + "R(%s)" % alphabet[counter+1] + ": eth%s - " % str(len(hosts_used[counter+1][0])//2) + dest_ip + "\n")
            else:
                src_ip = str(random.choice(list(ipaddress.ip_network(subnets_listed[counter]).hosts())))
                dest_ip = str(random.choice(list(ipaddress.ip_network(subnets_listed[counter + 1]).hosts())))
                star_net_config.write("R(%s)" % alphabet[counter] + ": eth%s - " % str(count+1) + src_ip +  " <-----> " + "R(%s)" % alphabet[counter+1] + ": eth%s - " % str(len(hosts_used[counter+1][0])//2) + dest_ip + "\n")
            star_net_config.write("\n")
            src_ip_list.append(alphabet[counter] + src_ip)
            dest_ip_list.append(alphabet[counter+1] + dest_ip)
            print(src_ip_list)
            print(dest_ip_list)
        count = 0
        counter+=1
    routing_table_store.close()
    star_net_config.close()
    with open("star/network_star.txt", 'r') as file:
        extract_ip = file.read().replace('\n', '')
        extract_ip = re.findall(r'(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})', extract_ip)
        if len(set(extract_ip)) != len(extract_ip):
            print("dupes found")
            plt.close()
            file.close()
            star_topology(network_model)
    print(union_edges)
    num_of_union_edges = len(union_edges) * 2
    print(num_of_union_edges)
    for x in union_edges:
        print("union " + str(x))
        for i in range(len(x)):
            print(x[i])
    routing_table_gen(network_model, subnet_routing_store, src_ip_list, dest_ip_list, subnets_listed, alphabet, subnets=0)

def routing_table_gen(network_model, subnet_routing_store, src_ip_list, dest_ip_list, subnets_listed, alphabet, subnets):
    if network_model == "b":
        routing_table_store = open("bus/default_routing_b.csv", "w+" , newline='') # Generate default gateways for the subnet hosts
        fields = ["Hostname", "Source IP", "Default Gateway"]
        writer = csv.DictWriter(routing_table_store, fields)
        writer.writeheader()
        sites = []
        with open("bus/network_bus.diag", "r") as file:
            alphabet = list(string.ascii_uppercase)
            read = file.readlines()
            sep = " "
            sep = sep.join(read)
            count_subnets = sep.split().count('network')
            print(count_subnets)
            rt_host_append = []
            rt_gw_append = []
            for count,line in enumerate(read): # Enumerate the configuration file and extract lines containing
                for x in range(count_subnets): # hostname and gateway identifiers
                    if "    %s" % alphabet[x] in line:
                            rt_host_append.append(line)
                    if "    gw" in line:
                            rt_gw_append.append(line)
            rt_host_append = ([s.strip('    ') for s in rt_host_append])
            rt_gw_append = ([s.strip('    ') for s in rt_gw_append])
            rt_gw_append = list(dict.fromkeys(rt_gw_append))
            rt_host_dict = {c: [w for w in rt_host_append if w.startswith(c)] for c in [w[:1] for w in rt_host_append]} # Nick (2020) Dictionary managment [Snippet]. https://stackoverflow.com/a/59852367 [Accessed 14/05/21]
            print(rt_host_dict)
            store_last_gw = rt_gw_append[-1]
            rt_gw_append.append(store_last_gw)
            limited_rt_gw = rt_gw_append[::2]
            print(limited_rt_gw)
            for (count, x) in enumerate(rt_host_dict):
                for y in rt_host_dict[x]: # Write a row in the csv file for each default gateway
                    writer.writerow({'Hostname': y[:2], 'Source IP': re.findall(r'"([^"]*)"', y)[0], 'Default Gateway': limited_rt_gw[count][:-2]})
            print(rt_gw_append)
            routing_table_store = open("bus/gw_routing_b.csv", "w+", newline='') # Generate routes between gateways
            print(subnets.values())
            subnets = list(subnets.values())
            rt_gw_append.pop()
            rt_gw_hostname = []
            for x in rt_gw_append:
                rt_gw_hostname.append(x[:3]) # Extract hostnames from the extracted configuration lines
            rt_gw_hostname = list(dict.fromkeys(rt_gw_hostname)) # Extract gateway names from hostname dictionary
            print(rt_gw_hostname)
            fields = ["Routing Table", "Destination Network", "Gateway", "Interface"]
            writer = csv.DictWriter(routing_table_store, fields)
            writer.writeheader()
            rt_gw_extracted_ip = []
            print(rt_gw_append)
            print(rt_gw_extracted_ip)
            rt_gw_extracted_ip = rt_gw_append
            for i in range(len(subnets)):
                sites.append("site"+alphabet[i]) # Create list of sites in the network
            for (count, x) in enumerate(rt_gw_hostname): # iterate gateways
                ol_flag = 0
                north_base_val = 1
                south_base_val = 2
                if count >= 2:
                    north_base_val += 1
                    south_base_val += 1
                for (count_sn, y) in enumerate(range(len(subnets))): # iterate subnets
                    if y == 0+count or y == 1+count: # subnets which are directly connected to the gateway are set to onlink
                        gw_var = "On-Link - " + x
                        ol_flag = 1
                        intf = rt_gw_extracted_ip[y+count][:-2]
                    else:
                        if count == 0: # If the iteration is top gateway in the network stack
                            gw_var = rt_gw_extracted_ip[2][:-2]
                            intf = rt_gw_extracted_ip[1][:-2]
                        elif count == len(rt_gw_hostname) - 1:# If the iteration is bottom gateway in the network stack
                            gw_var = rt_gw_extracted_ip[-3][:-2]
                            intf = rt_gw_extracted_ip[-2][:-2]
                        else: # If the iteration is a intermediary gateway, use position of onlink to determine direction of route
                            if ol_flag == 0:
                                gw_var = rt_gw_extracted_ip[north_base_val+count - 1][:-2]
                                intf = rt_gw_extracted_ip[north_base_val+count][:-2] # north
                            if ol_flag == 1:
                                gw_var = rt_gw_extracted_ip[south_base_val+count + 1][:-2]
                                intf = rt_gw_extracted_ip[south_base_val+count][:-2] # south
                    writer.writerow({'Routing Table': x, 'Destination Network': str(sites[y]) + " - " + str(subnets[y]), 'Gateway': gw_var, 'Interface': intf})
        exit()
    if network_model == "s":
        '''
        Host default gw routing for star done in star_topology. This process implements a similar method to that used 
        for the bus topology with the exception of a differing iteration and extraction of information from the configuraiton file
        '''
        routing_table_store_gw = open("star/gw_routing_s.csv", "w+")
        fields_gw = ["Routing Table", "Destination Network", "Gateway", "Interface"]
        writer_gw = csv.DictWriter(routing_table_store_gw, fields_gw)
        writer_gw.writeheader()
        print("\n")
        print(subnet_routing_store)
        print(src_ip_list)
        print(dest_ip_list)
        print(subnets_listed)
        for counter in range(len(subnets_listed)):
            temp_subnet_routing_store = subnet_routing_store[:]
            for (index, y) in enumerate(temp_subnet_routing_store):
                if alphabet[counter] in y:
                    del temp_subnet_routing_store[index]
            for x in range(len(subnets_listed)-1):
                if counter == 0:
                    dest_ip_w = dest_ip_list[0]
                    src_ip_w = src_ip_list[0]
                elif counter == len(subnets_listed) - 1:
                    dest_ip_w = src_ip_list[-1] # Swapped due to the way the src/dest ips are stored
                    src_ip_w = dest_ip_list[-1]
                else:
                    # Determine direction by x value in for loop
                    print(counter) # (alpha_listed.index(src_host))
                    print(x) # (alpha_listed.index(dest_host))
                    src_host = alphabet[counter]
                    dest_host = temp_subnet_routing_store[x][:-2][-1]
                    print(src_host)
                    print(dest_host)
                    if counter > x:
                        src_ip_w = [i for i in dest_ip_list if src_host in i][0]
                        dest_ip_w = src_ip_list[dest_ip_list.index(src_ip_w)] #[n for n in src_ip_list if dest_host in n][0][1:]

                    else:
                        src_ip_w = [i for i in src_ip_list if src_host in i][0]
                        dest_ip_w = dest_ip_list[src_ip_list.index(src_ip_w)] #[n for n in dest_ip_list if dest_host in n][0][1:]
                writer_gw.writerow({'Routing Table': "R(%s)" % alphabet[counter],'Destination Network': temp_subnet_routing_store[x][:-2], 'Gateway': dest_ip_w[1:], 'Interface': src_ip_w[1:]})

        routing_table_store_gw.close()
    exit()

def get_ports(hosts_used): # This function is called at the mid way point of both the star/bus_topology function
    web_ports = ["80", "443", "53"] # HTTP, HTTPS, DNS
    email_ports = ["25", "143", "110"] # SMTP, IMAP, POP3
    file_remote_ports = ["20", "21", "23", "3389", "22", "389", "445"] # FTP, TELNET, RDP, SSH, LDAP, SMB
    db_ports = ["3306", "1433", "5432"] # MySql, MS Sql server, PostgreSQL
    server_ports = ["67", "68"] # DHCP
    # web, email, file/remote share, database, server ports
    pick_server_farm = "siteA" #random.choice(list(hosts_used.keys()))
    join_list = web_ports + email_ports + file_remote_ports + db_ports + server_ports # combine list of ports
    pick_ports = random.sample(join_list, k=len(hosts_used.get(pick_server_farm))) # Pick a random number of ports based on the size of the server farm
    print("Server farm located at: " + str(pick_server_farm))
    print("Ports: \n " + str(pick_ports))
    return pick_server_farm, pick_ports

def main():
    while True:
        network_model = input(str("Choose a network model: Bus topology (b), Star Topology (s): "))
        if network_model.casefold() == "b".casefold():
            bus_topology(network_model)
        elif network_model.casefold() == "s".casefold():
            star_topology(network_model)
        else:
            print("Invalid option")

main()